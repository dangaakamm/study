一、正则表达式
     模式字符串
二、创建正则表达式
      1.通过构造函数
         reg=new RegExp("正则表达式"，“模式修正符”)
      2.通过字面量
         /RegExp/
三、方法
      1.RegExp.test(str)
         返回一个布尔值，它指出在被查找的字符串中是否存在
      2.RegExp.exec（str）
         受g的影响
四、模式修正符
       i      不区分大小写字母的匹配
      m     将字符串视为多行，修饰^和$
      g      全局匹配，找到所有匹配项
五、原子
      是正则最小的元素，可为英文，数字，标点符号
      \d  匹配任意你一个数字  [0-9]
      \D  与除数字以外的任何一个字符匹配  [^0-9]
      \w  与任意一个英文字母，数字，下划线匹配[a-z0-9A-Z]
      \W  除字母，数字，下划线外与任意一个字符匹配[^a-z0-9A-Z]
      \s    与任意一个空白字符匹配[\f\n\t\r\v]
      \S   除空白字符与任意字符匹配 [^\f\n\t\r\v]

            [\n\f\r\v\t]
          \f     换页字符
          \n    换行字符
          \r     回车字符
          \ t    制表符
          \ v   垂直制表符

六、原子表
      【】  只匹配其中的一个原子
七、元字符
      正则表达式中有一些特殊字符代表特殊意义
      .  除换行外的任何一个字符
      |  或的意思，匹配其中一项就代表匹配
      eg：匹配身份证号，旧版15位数字，新版18位数字
            /^\d{15}|\d{18}$/
八、反向引用
      匹配多个字符时用（）分组，分组代表一个原子集合或一个大原子，      并压入堆栈用于调用，组号从左到右计数调用时，字面量形式为/1，         构造函数为//1.
九、取消反向引用
      使用形如（？：pattern）的正则就可以避免保存括号内的匹配结果，      反向引用就失效了 
十、量词
    可以使用一些元字符，重复表示一些元子或元字符
    （贪婪）
    *重复零次或更多次
    +重复一次或更多次
    ？重复零次或一次
    {n}重复n次
    {n，}重复n次或更多次
    {n，m}重复n到m次
    （吝啬）
     *？重复任意次，尽可能少的重复
    +？重复一次或更多次，尽可能少的重复
    ？?重复零次或一次，尽可能少的重复
    {n，}？重复n次或更多次，尽可能少的重复
    {n，m}？重复n到m次，尽可能少的重复
十一、字符边界
     ^匹配字符串开始
     $匹配字符串结束
          单词边界
     \b匹配单词边界
    \B匹配除单词以外的部分
十二、replace（正则表达式，替换内容）
          str.search(regexp）
               regexp为正则表达式，返回索引位置，不支持全局索引，找到               就停止搜索，找不到返回-1
          split  截取
         match  查找 输出是一个数组，一次性就可输出，有g就不需调用
十三、常用的一些正则
        1.整数或小数   /^-?\d+\.?\d{0,3}$/
        2.只能输入数字    /^[0-9]*$/
        3.验证用户名和密码    /^[a-zA-Z]\w{5,18}$/
        4.验证电话号码    /(?:\(\d{3,4}\)|\d{3,4}-?)\d{8}/
        5.验证身份证号    /^\d{15}|\d{18}$/
        6.验证Email地址    /^[a-zA-Z0-9]\w+@[a-zA-Z]+\.(com|cc|org|net|cn|com.cn)$/
        7.验证URL     "/^http://([\w-]+\.)+[\w-]+(/[w-/?%&=]*)?$/ "/^(http[s]?:)?(\/{2})?([a-z0-]+\.)?[a-z0-9]+(\.(com|cn|cc|org|net|com.cn))$/i
    
           
         







